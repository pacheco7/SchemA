<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="Z_SCHEMA_ATTRIBUTES" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" RMAND="001" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
 <textPool>
  <language SPRAS="D">
   <textElement ID="R" ENTRY="schema.org: INCLUDE append all attributes" LENGTH="41 "/>
  </language>
 </textPool>
 <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include  z_schema_attributes
*&amp;---------------------------------------------------------------------*

*&amp;---------------------------------------------------------------------*
*&amp; SchemA
*&amp; The schema.org ABAP Framework
*&amp; Copyright (C) 2016 Uwe Fetzer together with the SCN ABAP community
*&amp;
*&amp; Project home: https://github.com/se38/SchemA
*&amp;
*&amp; Published under Apache License, Version 2.0
*&amp; http://www.apache.org/licenses/LICENSE-2.0.html
*&amp;---------------------------------------------------------------------*

**********************************************************************
* with describe_by_name we only get the attributes of the current
* class, but we need also the attributes for the super classes
* (complete hierarchy) -&gt; this code must be included in all
* append_attributes methods:
* &quot;INCLUDE z_schema_attributes_super.&quot;
**********************************************************************

    DATA descr TYPE REF TO cl_abap_classdescr.
    DATA classname TYPE seoclsname.
    classname = sy-repid(30).
    TRANSLATE classname USING &apos;= &apos;.
    descr ?= cl_abap_typedescr=&gt;describe_by_name( classname ).
    CHECK descr IS BOUND.

    &quot;*--- try to get values for all attributes of the current class ---*
    LOOP AT descr-&gt;attributes ASSIGNING FIELD-SYMBOL(&lt;attribute&gt;)
      WHERE is_constant IS INITIAL.

      &quot;*--- call the getter method of this attribute ---*
      DATA attribute_value   TYPE string.
      DATA attribute_value_o TYPE REF TO zcl_schema_thing.
      DATA attribute_value_t TYPE z_schema_thing_t.

      DATA parameters TYPE abap_parmbind_tab.
      DATA parameter TYPE abap_parmbind.

      CLEAR parameters.
      parameter-name = &apos;R_RESULT&apos;.

      parameter-value = COND #(
                                WHEN &lt;attribute&gt;-type_kind = &apos;r&apos; THEN REF #( attribute_value_o )
                                WHEN &lt;attribute&gt;-type_kind = &apos;h&apos; THEN REF #( attribute_value_t )
                                ELSE REF #( attribute_value )
                              ).

      INSERT parameter INTO TABLE parameters.

      DATA(method_name) = |GET_{ &lt;attribute&gt;-name }|.

      TRY.
          CALL METHOD (method_name)
            PARAMETER-TABLE parameters.
        CATCH cx_sy_dyn_call_illegal_method INTO DATA(zx) ##no_handler.
          CONTINUE.
      ENDTRY.

      &quot;*--- attributes from the class ---*
      CASE &lt;attribute&gt;-type_kind.

        WHEN &apos;r&apos;.       &quot;an object itself

          CHECK attribute_value_o IS BOUND.

          DATA(json) = attribute_value_o-&gt;get_json( abap_true ).   &quot;get JSON w/o leading context attribute
          CHECK json IS NOT INITIAL.

          json = &apos;&quot;&apos; &amp;&amp; /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ) &amp;&amp; &apos;&quot;: { &apos; &amp;&amp; json &amp;&amp; &apos; }&apos;.
*          REPLACE &apos;result&apos; IN json WITH /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ).

          IF c_json IS NOT INITIAL.
            c_json = c_json &amp;&amp; | , |.
          ENDIF.

          c_json = c_json &amp;&amp; json.

        WHEN &apos;h&apos;.       &quot;table of objects

          CHECK attribute_value_t IS NOT INITIAL.

          IF c_json IS NOT INITIAL.
            c_json = c_json &amp;&amp; | , |.
          ENDIF.

          c_json = c_json &amp;&amp; &apos;&quot;&apos; &amp;&amp; /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ) &amp;&amp; &apos;&quot;: [&apos;.

          LOOP AT attribute_value_t INTO attribute_value_o.

            IF sy-tabix &gt; 1.
              c_json = c_json &amp;&amp; | , |.
            ENDIF.

            json = attribute_value_o-&gt;get_json( abap_true ).   &quot;get JSON w/o surrounding brackets
            CHECK json IS NOT INITIAL.

            IF sy-tabix &gt; 1.
              c_json = c_json &amp;&amp; &apos;,&apos;.
            ENDIF.

            c_json = c_json &amp;&amp; &apos;{ &apos; &amp;&amp; json &amp;&amp; &apos; }&apos;.
          ENDLOOP.

          c_json = c_json &amp;&amp; &apos; ]&apos;.

        WHEN &apos;I&apos;.                &quot;Integer
          CHECK attribute_value CN &apos;0 &apos;.

          &quot;*--- append attribute JSON ---*
          DATA(attribute_name) = /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ).

          IF c_json IS NOT INITIAL.
            c_json = c_json &amp;&amp; &apos;,&apos;.
          ENDIF.

          c_json = c_json &amp;&amp; |&quot;{ attribute_name }&quot;: { attribute_value }|.

        WHEN &apos;D&apos;.                &quot;Date
          CHECK attribute_value CN &apos;0 &apos;.

          &quot;*--- append attribute JSON ---*
          attribute_name = /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ).

          IF c_json IS NOT INITIAL.
            c_json = c_json &amp;&amp; &apos;,&apos;.
          ENDIF.

          DATA date TYPE d.
          date = attribute_value.
          c_json = c_json &amp;&amp; |&quot;{ attribute_name }&quot;: &quot;{ date DATE = ISO }&quot;|.

        WHEN OTHERS.

          CHECK attribute_value IS NOT INITIAL.

          &quot;*--- append attribute JSON ---*
          attribute_name = /ui2/cl_json=&gt;pretty_name( in = &lt;attribute&gt;-name ).

          IF c_json IS NOT INITIAL.
            c_json = c_json &amp;&amp; &apos;,&apos;.
          ENDIF.

          c_json = c_json &amp;&amp; |&quot;{ attribute_name }&quot;: &quot;{ attribute_value }&quot;|.
      ENDCASE.

    ENDLOOP.</source>
</PROG>
